#pragma once

#include "eval.h"

u16 get_large_tiles_mask(const u64 board, const u8 threshold) {
    u16 mask = 0;
    for (u8 i = 0; i < 16; ++i) {
        const u8 cell = (board >> (i * 4)) & 0xFu;
        if (cell >= threshold) {
            mask |= u16(1) << cell;
        }
    }
    return mask;
}

u64 filter_large_tiles(const u64 board, u8 threshold) {
    u64 filtered = 0;
    for (u8 i = 0; i < 16; ++i) {
        const u8 cell = (board >> (i * 4)) & 0xFu;
        if (cell >= threshold) {
            filtered |= u64(cell) << (i * 4);
        }
    }
    return filtered;
}

u64 get_filtered(u64 board, u8 threshold) {
    u64 filtered = 0;
    for (u64 b: get_transformations(board)) {
        filtered = max(filtered, filter_large_tiles(b, threshold));
    }
    return filtered;
}

void space_perf_test(r_t gigabytes) {
    const size_t num_bytes = size_t(gigabytes * E(30));
    const size_t num_elements = num_bytes / sizeof(u64);

    try {
        vector<u64> large_array(num_elements);
        large_array[0] = 0;
        cout << "Allocated " << num_bytes << " bytes" << endl;
        for (size_t i = 1; i < num_elements; ++i) {
            large_array[i] = large_array[i - 1] + 1;
        }
        cout << "Finished: " << large_array[num_elements - 1] << endl;
    } catch (const std::bad_alloc &e) {
        cout << "Failed to allocate " << num_bytes << " bytes" << endl;
        throw e;
    }
}

void print_search_info() {
    /*
        - - 1 6
        1 3 3 8
        - 2 5 B
        2 1 3 C
     copy this board
     */

    u64 board = 0x00161338025B213Cull;
    /*
        - 1 8 9
        - 1 7 B
        1 2 6 C
        2 3 4 D
     copy this board
     */
    board = 0x0189017B126C234Dull;
    /*print_board(board);
    for (u8 depth = 0; depth <= 5; ++depth) {
        cnt = 0;
        cnt_adds = 0;
        cnt_state = 0;
        cnt_afterstate = 0;
        cnt_probs.clear();
        auto start = time_now();
        r_t used_prob = 1 / get_min_prob(depth, 0.05);
        cout << expectimax_limited_depth_prob(board, depth, used_prob, tuples_4_stage_1).eval << endl;
        cout << "Depth: " << (int) depth << endl;
        cout << "Time: " << time_since(start) / 1e6 << endl;
        cout << "States: " << cnt_state << " (" << cnt_state / time_since(start) * 1e6 << " states/s)" << endl;
        cout << "Afterstates: " << cnt_afterstate << " (" << cnt_afterstate / time_since(start) * 1e6 << " afterstates/s)" << endl;
        cout << "Total: " << cnt_adds << " (" << cnt_adds / time_since(start) * 1e6 << " states/s)" << endl;
        cout << "Small prob: " << cnt << endl;
        cout << "Max prob: " << used_prob << endl;
        cout << "Depths:" << endl;
        vector<pair<u8, r_t>> all_depths;
        for (const auto &[depth, cnt]: cnt_depths) {
            all_depths.emplace_back(depth, cnt);
        }
        sort(all_depths.begin(), all_depths.end(), [](const auto &a, const auto &b) {
            return a.first > b.first;
        });
        for (const auto &p: all_depths) {
            cout << (int) p.first << " " << p.second << endl;
        }
        cout << "Probs:" << endl;
        vector<pair<r_t, u64>> all_probs;
        for (const auto &[prob, cnt]: cnt_probs) {
            all_probs.emplace_back(prob, cnt);
        }
        sort(all_probs.begin(), all_probs.end(), [](const auto &a, const auto &b) {
            return a.first > b.first;
        });
        for (const auto &p: all_probs) {
            cout << used_prob / p.first << " " << p.second << endl;
        }
        cout << endl << endl;
    }*/
}

void print_formation_stats() {
    /*count_occurrences(9, 10000);
    auto sorted = print_mask_probs();
    cout << endl;
    for (const auto &p: sorted) {
        for (u8 i = 0; i < 16; ++i) {
            if (p.first & (u16(1) << i)) {
                cout << "1";
            } else {
                cout << "0";
            }
        }
        cout << endl;
        print_board_probs(p.first);
    }*/


    /*run_algorithm_episodes(10, 10, [](const u64 board, NTuple &tuples) {
        if (++cnt > cnt_2) {
            cnt_2 += 2000;
            cout << "Deci games: " << cnt / 2000 << endl;
        }
        //print_board(board);
        return expectimax_limited_states(board, 1000, 0.01, tuples).dir;
        //const u8 depth = 3;
        //return expectimax_limited_depth_prob(board, depth, 1 / get_min_prob(depth, 0.05), tuples).dir;
        //return eval_state(board, tuples).dir;
    });*/

    /*vector<pair<u64, r_t>>
    board_probs;
    u64 total = 0;
    for (const auto &[board, cnt]: count_boards) {
        total += cnt;
    }
    for (const auto &[board, cnt]: count_boards) {
        board_probs.emplace_back(board, r_t(cnt) / r_t(total));
    }
    sort(board_probs.begin(), board_probs.end(), [](const auto &a, const auto &b) {
        return a.second > b.second;
    });
    for (const auto &p: board_probs) {
        cout << p.second << endl;
        print_board(p.first);
    }*/
}

array<u32, E(16)> count_masks;
u8 large_th = 6;

unordered_map<u64, u64> count_boards;

void print_reach_probs() {
    count_masks.fill(0);
    run_algorithm_episodes(5000, 10, [](const u64 board, NTuple &tuples) {
        /*if (++cnt > cnt_2) {
            cnt_2 += 200000;
            cout << "Deca Games: " << cnt / 200000 << endl;
        }*/
        //return eval_state(board, tuples).dir;
        return expectimax_limited_evals(board, 1000, 0.015, tuples).dir;
        //return expectimax_limited_states(board, 500, 0.01, tuples).dir;
    });

    vector<pair<u32, u64>> stats;
    for (u32 i = 0; i < E(16); i += E(large_th)) {
        stats.emplace_back(i, count_masks[i]);
    }
    cout << endl;
    for (u32 i = stats.size() - 1; i > 0; --i) {
        stats[i - 1].second += stats[i].second;
    }
    cout << endl;
    vector<tuple<u32, u32, r_t, r_t>> probs;
    for (u32 i = 0; i < stats.size() - 1; ++i) {
        if (stats[i].second == 0) {
            probs.emplace_back(stats[i].first, stats[i + 1].first, 0, 0);
        } else {
            probs.emplace_back(stats[i].first, stats[i + 1].first,
                               r_t(stats[i + 1].second) / r_t(stats[i].second),
                               r_t(stats[i + 1].second) / r_t(stats[i].second));
        }
    }
    cout << endl;
    for (u32 i = 1; i < probs.size(); ++i) {
        get<3>(probs[i]) *= get<3>(probs[i - 1]);
    }
    for (const auto &p: probs) {
        cout << get<0>(p) << "->" << get<1>(p) << ": " << get<2>(p) << " " << get<3>(p) << endl;
    }
    cout << endl;
}

r_t get_tile_score(const u8 tile) {
    if (tile < 2) { return 0; }
    if (tile == 2) { return r_t(36) / 11; }
    return 2 * get_tile_score(tile - 1) + pow(2, tile);
}

r_t get_newtile_score(const u32 sum, const u8 newtile) {
    u16 sum_mask = 0;
    for (u8 i = 0; i < 16; ++i) {
        if ((sum >> i) & 1) {
            sum_mask |= 1 << i;
        }
    }
    r_t score = 0;
    score += get_tile_score(newtile);
    for (u8 i = newtile; i < 16; ++i) {
        if ((sum_mask >> i) & 1) {
            score += pow(2, i + 1);
        } else {
            break;
        }
    }
    return score;
}

r_t get_newtiles_score(u32 sum, const u8 newtile, const u32 count) {
    r_t score = 0;
    for (u32 i = 0; i < count; ++i) {
        score += get_newtile_score(sum, newtile);
        sum += pow(2, newtile);
    }
    return score;
}

void print_newtile_score_for_all_additions(const u8 newtile) {
    for (u32 i = 0; i < E(16) - E(newtile); i += E(newtile)) {
        cout << i << " " << get_newtile_score(i, newtile) << endl;
    }
}

/*vector<pair<u32, r_t>> get_potential_newtile_scores(const u32 sum, const u8 newtile) {
    vector<pair<u32, r_t>> scores;
    for (u32 i = 0; i < E(16) - E(newtile); i += E(newtile)) {
        scores.emplace_back(i, get_newtile_score(
    }
    sort(scores.begin(), scores.end(), [](const auto &a, const auto &b) {
        return a.second > b.second;
    });
    return scores;
}*/

//vector of (index, d_prob, prob, d_score, score, score_lost)

vector<pair<u32, r_t>> calculate_d_probs(vector<pair<u32, u64>> stats) {
    vector<pair<u32, r_t>> d_probs;
    for (u32 i = 0; i < stats.size() - 1; ++i) {
        if (stats[i].second == 0) {
            d_probs.emplace_back(stats[i].first, 0);
        } else {
            d_probs.emplace_back(stats[i].first, r_t(stats[i + 1].second) / r_t(stats[i].second));
        }
    }
    return d_probs;
}

vector<pair<u32, r_t>> calculate_d_probs_from_probs(vector<pair<u32, r_t>> probs) {
    vector<pair<u32, r_t>> d_probs;
    d_probs.emplace_back(probs[0].first, probs[0].second);
    for (u32 i = 1; i < probs.size(); ++i) {
        if (probs[i - 1].second == 0) {
            d_probs.emplace_back(probs[i].first, 0);
        } else {
            d_probs.emplace_back(probs[i].first, probs[i].second / probs[i - 1].second);
        }
    }
    return d_probs;
}

vector<pair<u32, r_t>> calculate_probs(vector<pair<u32, r_t>> d_probs) {
    vector<pair<u32, r_t>> probs;
    for (u32 i = 1; i < d_probs.size(); ++i) {
        d_probs[i].second *= d_probs[i - 1].second;
    }
    return d_probs;
}

vector<pair<u32, r_t>> calculate_d_scores(vector<pair<u32, r_t>> probs, const u8 newtile) {
    vector<pair<u32, r_t>> d_scores;
    for (const auto &p: probs) {
        d_scores.emplace_back(p.first, get_newtile_score(p.first, newtile));
    }
    return d_scores;
}

/*//d_prob[i] is successing at stage i, and d_score[i] is the score gained at stage i
//calculate the expected total score when starting at stage i, with all stages succeeding
vector<pair<u32, r_t>> calculate_scores(vector<pair<u32, r_t>> d_probs, vector<pair<u32, r_t>> d_scores) {
    vector<pair<u32, r_t>> scores(d_probs.size());
    scores[d_probs.size() - 1] = {d_scores[d_scores.size() - 1].first, d_scores[d_probs.size() - 1].second * d_probs[d_probs.size() - 1].second};
    for (u32 i = d_probs.size() - 1; i > 0; --i) {
        scores[i - 1] = {d_probs[i - 1].first, (scores[i].second + d_scores[i - 1].second) * d_probs[i - 1].second};
    }
    return scores;
}*/

vector<pair<u32, r_t>> calculate_scores(vector<pair<u32, r_t>> d_scores) {
    vector<pair<u32, r_t>> scores;
    scores.emplace_back(d_scores[0].first, d_scores[0].second);
    for (u32 i = 1; i < d_scores.size(); ++i) {
        scores.emplace_back(d_scores[i].first, scores[i - 1].second + d_scores[i].second);
    }
    return scores;
}

vector<pair<u32, r_t>> calculate_scores_gains(vector<pair<u32, r_t>> scores, vector<pair<u32, r_t>> probs) {
    vector<pair<u32, r_t>> score_gains;
    score_gains.emplace_back(scores[0].first, scores[0].second * (1 - probs[0].second));
    /*for (u32 i = 0; i < scores.size() - 1; ++i) {
        score_gains.emplace_back(scores[i].first, (probs[i].second - probs[i + 1].second) * scores[i - 1].second);
    }*/
    for (u32 i = 1; i < scores.size(); ++i) {
        score_gains.emplace_back(scores[i].first, (probs[i - 1].second - probs[i].second) * scores[i - 1].second);
    }
    return score_gains;
}

vector<pair<u32, r_t>> calculate_cumulative_score_gains(vector<pair<u32, r_t>> score_gains) {
    //from backwards
    vector<pair<u32, r_t>> cumulative_score_gains(score_gains.size());
    cumulative_score_gains[score_gains.size() - 1] = {score_gains[score_gains.size() - 1].first, score_gains[score_gains.size() - 1].second};
    for (u32 i = score_gains.size() - 1; i > 0; --i) {
        cumulative_score_gains[i - 1] = {score_gains[i - 1].first, cumulative_score_gains[i].second + score_gains[i - 1].second};
    }
    return cumulative_score_gains;
}

//G = 8
//feDCBa9876000000
//0011101111000000
//CBA9800000000000

u8 calculate_G(const u32 sum, const u8 minG) {
    u8 G = 42;
    for (u8 i = minG; i < 16; ++i) {
        if ((sum >> i) & 1) {
            G = i;
            break;
        }
    }
    return G;

}

u8 calculate_space(const u32 sum, const u8 G) {
    if (sum % E(G) != 0) {
        assert(false);
    }
    u16 sum_mask = 0;
    for (u8 i = G; i < 16; ++i) {
        if ((sum >> i) & 1) {
            sum_mask |= 1 << i;
        }
    }
    u8 spaces = 16 - popcnt(sum_mask);
    return spaces;
}

//stage start, d_prob, prob, d_score, score
//calculate_stage_starts

void print_all_prob_score_stuff() {
    u8 newtile = 6;
    vector<r_t> probs = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.998, 0.998, 0.998, 0.998, 0.998, 0.998, 0.998, 0.998, 0.998, 0.998, 0.998, 0.998, 0.998, 0.998, 0.998, 0.998, 0.998, 0.998, 0.998, 0.998, 0.998, 0.998, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.994, 0.992, 0.992, 0.992, 0.992, 0.992, 0.992, 0.992, 0.992, 0.992, 0.992, 0.992, 0.992, 0.992, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.988, 0.988, 0.988, 0.988, 0.988, 0.988,
                         0.988, 0.988, 0.988, 0.988, 0.988, 0.988, 0.988, 0.988, 0.988, 0.988, 0.986, 0.986, 0.986, 0.986, 0.986, 0.984, 0.984, 0.984, 0.984, 0.984, 0.984, 0.984, 0.984, 0.984, 0.984, 0.984, 0.984, 0.984, 0.984, 0.984, 0.984, 0.984, 0.984, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.982, 0.98, 0.98, 0.98, 0.978, 0.976, 0.976, 0.976, 0.976, 0.976, 0.976, 0.974, 0.974, 0.974, 0.974, 0.974, 0.974, 0.97, 0.97, 0.966, 0.962, 0.954, 0.954, 0.954, 0.954, 0.954, 0.954, 0.954, 0.954, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.952, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.95, 0.948, 0.948, 0.948, 0.948, 0.948, 0.948, 0.948, 0.948, 0.948, 0.948, 0.948, 0.948,
                         0.948, 0.948, 0.948, 0.948, 0.948, 0.948, 0.948, 0.948, 0.948, 0.948, 0.948, 0.948, 0.948, 0.946, 0.946, 0.946, 0.946, 0.946, 0.946, 0.946, 0.944, 0.944, 0.944, 0.944, 0.944, 0.942, 0.942, 0.942, 0.942, 0.942, 0.942, 0.942, 0.942, 0.942, 0.942, 0.942, 0.942, 0.942, 0.942, 0.942, 0.942, 0.942, 0.942, 0.94, 0.94, 0.94, 0.94, 0.938, 0.938, 0.938, 0.938, 0.938, 0.938, 0.938, 0.938, 0.938, 0.938, 0.938, 0.938, 0.938, 0.938, 0.938, 0.938, 0.936, 0.936, 0.936, 0.936, 0.936, 0.936, 0.934, 0.934, 0.932, 0.932, 0.932, 0.932, 0.932, 0.932, 0.932, 0.932, 0.93, 0.928, 0.926, 0.924, 0.924, 0.922, 0.92, 0.92, 0.92, 0.92, 0.92, 0.92, 0.92, 0.92, 0.92, 0.92, 0.92, 0.92, 0.92, 0.92, 0.92, 0.92, 0.92, 0.92, 0.92, 0.92, 0.92, 0.92, 0.918, 0.918, 0.918, 0.918, 0.916, 0.916, 0.916, 0.914, 0.914, 0.914, 0.912, 0.912, 0.912, 0.912, 0.91, 0.91, 0.908, 0.908, 0.908, 0.908, 0.908, 0.908, 0.908, 0.908, 0.906, 0.906, 0.902, 0.902, 0.9, 0.9, 0.896, 0.896, 0.896, 0.896, 0.894, 0.894, 0.892,
                         0.892, 0.888, 0.888, 0.884, 0.882, 0.868, 0.868, 0.868, 0.868, 0.868, 0.868, 0.868, 0.868, 0.868, 0.868, 0.868, 0.868, 0.868, 0.868, 0.868, 0.868, 0.866, 0.866, 0.866, 0.866, 0.866, 0.866, 0.866, 0.864, 0.862, 0.862, 0.86, 0.86, 0.856, 0.856, 0.852, 0.84, 0.828, 0.828, 0.828, 0.828, 0.828, 0.828, 0.822, 0.822, 0.816, 0.816, 0.814, 0.814, 0.812, 0.812, 0.804, 0.796, 0.774, 0.774, 0.772, 0.768, 0.766, 0.758, 0.748, 0.74, 0.722, 0.716, 0.71, 0.706, 0.676, 0.668, 0.64, 0.63, 0.53, 0.53, 0.53, 0.53, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.528, 0.526, 0.526, 0.526, 0.526, 0.526, 0.526, 0.526, 0.526, 0.526, 0.526, 0.526, 0.526, 0.526, 0.526, 0.526, 0.526, 0.526, 0.526, 0.526, 0.526, 0.526, 0.526, 0.526, 0.526, 0.524, 0.524, 0.524, 0.524, 0.524, 0.524, 0.524, 0.524,
                         0.524, 0.524, 0.524, 0.524, 0.522, 0.522, 0.522, 0.522, 0.522, 0.522, 0.522, 0.522, 0.522, 0.522, 0.522, 0.522, 0.522, 0.522, 0.522, 0.522, 0.52, 0.52, 0.52, 0.52, 0.518, 0.516, 0.516, 0.516, 0.516, 0.516, 0.514, 0.514, 0.514, 0.514, 0.514, 0.514, 0.514, 0.514, 0.514, 0.514, 0.512, 0.512, 0.512, 0.512, 0.512, 0.512, 0.512, 0.512, 0.51, 0.51, 0.508, 0.508, 0.508, 0.508, 0.506, 0.506, 0.504, 0.504, 0.504, 0.504, 0.504, 0.504, 0.504, 0.504, 0.504, 0.504, 0.504, 0.504, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.502, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.494, 0.494, 0.492, 0.492, 0.492, 0.492, 0.49, 0.49, 0.484, 0.484, 0.474, 0.474, 0.474, 0.474, 0.474, 0.474, 0.474, 0.474, 0.474, 0.474, 0.472, 0.472, 0.472, 0.472, 0.472, 0.472, 0.47, 0.47, 0.468, 0.466, 0.464, 0.464, 0.464,
                         0.464, 0.46, 0.46, 0.46, 0.456, 0.456, 0.456, 0.448, 0.446, 0.444, 0.444, 0.442, 0.438, 0.436, 0.436, 0.434, 0.432, 0.428, 0.428, 0.426, 0.426, 0.424, 0.422, 0.422, 0.42, 0.414, 0.412, 0.412, 0.412, 0.402, 0.4, 0.398, 0.396, 0.386, 0.384, 0.376, 0.376, 0.366, 0.36, 0.342, 0.332, 0.288, 0.288, 0.288, 0.288, 0.286, 0.286, 0.286, 0.286, 0.286, 0.286, 0.286, 0.286, 0.286, 0.286, 0.284, 0.282, 0.28, 0.28, 0.28, 0.28, 0.278, 0.278, 0.278, 0.278, 0.27, 0.27, 0.27, 0.268, 0.266, 0.264, 0.262, 0.26, 0.25, 0.25, 0.25, 0.25, 0.246, 0.246, 0.246, 0.246, 0.246, 0.246, 0.246, 0.246, 0.244, 0.244, 0.244, 0.244, 0.238, 0.238, 0.238, 0.238, 0.236, 0.236, 0.232, 0.23, 0.22, 0.22, 0.22, 0.218, 0.212, 0.208, 0.204, 0.198, 0.194, 0.194, 0.194, 0.194, 0.194, 0.194, 0.194, 0.194, 0.194, 0.194, 0.194, 0.194, 0.194, 0.192, 0.186, 0.184, 0.176, 0.176, 0.176, 0.176, 0.17, 0.168, 0.166, 0.164, 0.156, 0.152, 0.152, 0.15, 0.142, 0.142, 0.136, 0.13, 0.118, 0.118, 0.116, 0.116, 0.112, 0.112,
                         0.106, 0.102, 0.096, 0.096, 0.092, 0.088, 0.078, 0.07, 0.062, 0.06, 0.058, 0.056, 0.044, 0.038, 0.028, 0.028, 0.024, 0.02, 0.006, 0.006, 0.006, 0.006, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

    probs = {0.99997, 0.99992, 0.99991, 0.99977, 0.99977, 0.99975, 0.99975, 0.9997, 0.9997, 0.99969, 0.99969, 0.99959, 0.99959, 0.99934, 0.99931, 0.99809, 0.99809, 0.99809, 0.99809, 0.99808, 0.99808, 0.99799, 0.99799, 0.9977, 0.99768, 0.99764, 0.99763, 0.9975, 0.99749, 0.99732, 0.99732, 0.99691, 0.9969, 0.99681, 0.99679, 0.99664, 0.99664, 0.99663, 0.99659, 0.99647, 0.99645, 0.99643, 0.99641, 0.99632, 0.99632, 0.99604, 0.99603, 0.99548, 0.99548, 0.99544, 0.99543, 0.99528, 0.99527, 0.99501, 0.99499, 0.99431, 0.9943, 0.99427, 0.99424, 0.99405, 0.99402, 0.99389, 0.99381, 0.99319, 0.99318, 0.99317, 0.99317, 0.99304, 0.99304, 0.99301, 0.99299, 0.99288, 0.99287, 0.99284, 0.99283, 0.99273, 0.99273, 0.99266, 0.99263, 0.99218, 0.99218, 0.99214, 0.99212, 0.99199, 0.99198, 0.99178, 0.99175, 0.9912, 0.9912, 0.99119, 0.99114, 0.99092, 0.99092, 0.9908, 0.99065, 0.99008, 0.99005, 0.9899, 0.98987, 0.98976, 0.98975, 0.98942, 0.98942, 0.98903, 0.98903, 0.98892, 0.98887, 0.9887, 0.98867, 0.98852, 0.98844,
             0.98779, 0.98775, 0.98766, 0.98755, 0.98705, 0.98698, 0.98674, 0.9865, 0.98548, 0.98545, 0.98515, 0.98496, 0.98423, 0.98408, 0.98334, 0.98272, 0.97888, 0.97887, 0.97881, 0.97879, 0.97867, 0.97867, 0.97865, 0.97865, 0.97851, 0.9785, 0.97849, 0.97846, 0.97837, 0.97837, 0.97824, 0.97824, 0.97776, 0.97776, 0.9777, 0.97769, 0.97761, 0.97761, 0.97749, 0.97748, 0.97691, 0.97689, 0.97685, 0.97683, 0.97666, 0.97663, 0.97648, 0.97635, 0.9758, 0.97576, 0.97567, 0.97563, 0.97542, 0.9754, 0.97518, 0.97518, 0.9747, 0.9747, 0.97467, 0.97464, 0.97445, 0.97444, 0.97429, 0.97416, 0.97351, 0.9735, 0.97339, 0.97333, 0.97297, 0.97292, 0.97271, 0.97251, 0.9714, 0.97137, 0.9711, 0.97092, 0.97015, 0.96999, 0.96912, 0.96836, 0.96451, 0.9644, 0.9643, 0.96426, 0.96408, 0.96408, 0.96391, 0.96389, 0.96338, 0.96334, 0.96327, 0.96325, 0.96297, 0.96296, 0.96277, 0.96262, 0.96185, 0.96185, 0.96168, 0.96162, 0.96115, 0.96108, 0.96078, 0.96066, 0.95967, 0.95965, 0.95938, 0.95925, 0.95855, 0.95833, 0.95756,
             0.95683, 0.95309, 0.95296, 0.95267, 0.95248, 0.95171, 0.95156, 0.95102, 0.95077, 0.9492, 0.94909, 0.94871, 0.94836, 0.94741, 0.94717, 0.94602, 0.9452, 0.94067, 0.94049, 0.93978, 0.93933, 0.93758, 0.93697, 0.93534, 0.93442, 0.92983, 0.92917, 0.92745, 0.92581, 0.91929, 0.91725, 0.907909, 0.902209, 0.879969, 0.879919, 0.879809, 0.879769, 0.879659, 0.879659, 0.879519, 0.879509, 0.878669, 0.878669, 0.878659, 0.878659, 0.878369, 0.878369, 0.878159, 0.878149, 0.877439, 0.877429, 0.877319, 0.877239, 0.876689, 0.876629, 0.876399, 0.876339, 0.874259, 0.874239, 0.874089, 0.873909, 0.872949, 0.872769, 0.872089, 0.871689, 0.867869, 0.867829, 0.867729, 0.867589, 0.866849, 0.866799, 0.866239, 0.866059, 0.864689, 0.864659, 0.864409, 0.864309, 0.863739, 0.863689, 0.863399, 0.863249, 0.862119, 0.862059, 0.861869, 0.861809, 0.861109, 0.861069, 0.860679, 0.860469, 0.859109, 0.859069, 0.858589, 0.858429, 0.857539, 0.857259, 0.856269, 0.855469, 0.851429, 0.851419, 0.851379, 0.851379, 0.851229,
             0.851209, 0.851069, 0.850989, 0.850199, 0.850179, 0.850039, 0.849969, 0.849049, 0.848969, 0.848489, 0.848129, 0.846369, 0.846269, 0.846119, 0.845999, 0.845299, 0.845219, 0.844739, 0.844429, 0.843029, 0.842919, 0.842649, 0.842449, 0.841719, 0.841519, 0.840499, 0.839759, 0.835829, 0.835769, 0.835589, 0.835479, 0.834859, 0.834819, 0.834519, 0.834209, 0.832659, 0.832639, 0.832219, 0.832039, 0.831129, 0.830979, 0.830159, 0.829489, 0.825619, 0.825518, 0.825089, 0.824858, 0.823648, 0.823368, 0.822149, 0.821279, 0.817478, 0.817098, 0.815828, 0.814908, 0.809958, 0.808198, 0.800768, 0.796428, 0.777578, 0.777478, 0.777258, 0.777208, 0.776978, 0.776968, 0.776828, 0.776778, 0.775768, 0.775758, 0.775678, 0.775648, 0.775198, 0.775178, 0.774928, 0.774768, 0.773898, 0.773868, 0.773748, 0.773658, 0.773078, 0.773018, 0.772548, 0.772288, 0.771048, 0.770988, 0.770748, 0.770518, 0.769498, 0.769148, 0.768518, 0.767898, 0.764978, 0.764918, 0.764738, 0.764608, 0.763988, 0.763928, 0.763628,
             0.763298, 0.761618, 0.761538, 0.761228, 0.761068, 0.760068, 0.759758, 0.758818, 0.758008, 0.754058, 0.753928, 0.753428, 0.753067, 0.751747, 0.751567, 0.750387, 0.749577, 0.745777, 0.745397, 0.743977, 0.742917, 0.738427, 0.736727, 0.728647, 0.724527, 0.706437, 0.706357, 0.706097, 0.705957, 0.705127, 0.705067, 0.704567, 0.704237, 0.702567, 0.702447, 0.701937, 0.701497, 0.700057, 0.699617, 0.698327, 0.697157, 0.693107, 0.692937, 0.692267, 0.691757, 0.689427, 0.688817, 0.687157, 0.685627, 0.681427, 0.680497, 0.678307, 0.676607, 0.671167, 0.668937, 0.659436, 0.654456, 0.630616, 0.630076, 0.628226, 0.626776, 0.622116, 0.620786, 0.616916, 0.614246, 0.606906, 0.605836, 0.603046, 0.601106, 0.594536, 0.592146, 0.582276, 0.576586, 0.552185, 0.550565, 0.545945, 0.542685, 0.533535, 0.529895, 0.518415, 0.513055, 0.490295, 0.486335, 0.473235, 0.467465, 0.441564, 0.427644, 0.400344, 0.386664, 0.326053, 0.326043, 0.325983, 0.325973, 0.325893, 0.325893, 0.325813, 0.325813, 0.325473,
             0.325473, 0.325463, 0.325463, 0.325373, 0.325353, 0.325303, 0.325293, 0.325153, 0.325153, 0.325103, 0.325093, 0.324933, 0.324933, 0.324823, 0.324803, 0.324293, 0.324293, 0.324263, 0.324263, 0.323973, 0.323943, 0.323623, 0.323463, 0.322273, 0.322203, 0.322083, 0.322053, 0.321883, 0.321873, 0.321783, 0.321753, 0.320923, 0.320923, 0.320903, 0.320883, 0.320633, 0.320583, 0.320313, 0.320193, 0.319693, 0.319683, 0.319603, 0.319573, 0.319253, 0.319233, 0.319053, 0.318903, 0.318183, 0.318153, 0.317973, 0.317883, 0.317513, 0.317393, 0.316783, 0.316123, 0.312323, 0.312263, 0.312203, 0.312183, 0.312043, 0.312033, 0.311973, 0.311923, 0.311403, 0.311403, 0.311363, 0.311333, 0.311123, 0.311083, 0.310873, 0.310783, 0.310313, 0.310243, 0.310123, 0.310053, 0.309733, 0.309653, 0.309513, 0.309343, 0.308393, 0.308343, 0.308133, 0.307963, 0.307273, 0.307143, 0.306673, 0.306193, 0.304553, 0.304553, 0.304493, 0.304463, 0.304083, 0.304053, 0.303803, 0.303653, 0.302693, 0.302633, 0.302413,
             0.302293, 0.301653, 0.301453, 0.300953, 0.300513, 0.298743, 0.298663, 0.298393, 0.298183, 0.297513, 0.297303, 0.296653, 0.296003, 0.294253, 0.294073, 0.293333, 0.292733, 0.290703, 0.290083, 0.286933, 0.284973, 0.278433, 0.278363, 0.278273, 0.278263, 0.278183, 0.278173, 0.278123, 0.278103, 0.277743, 0.277733, 0.277703, 0.277673, 0.277483, 0.277463, 0.277323, 0.277153, 0.276703, 0.276693, 0.276593, 0.276523, 0.276203, 0.276163, 0.275903, 0.275703, 0.274833, 0.274813, 0.274703, 0.274553, 0.273873, 0.273713, 0.272973, 0.272533, 0.270843, 0.270803, 0.270733, 0.270703, 0.270292, 0.270232, 0.269973, 0.269743, 0.268833, 0.268762, 0.268503, 0.268243, 0.267653, 0.267463, 0.266673, 0.266133, 0.264203, 0.264163, 0.263932, 0.263662, 0.262812, 0.262652, 0.261952, 0.261392, 0.259772, 0.259472, 0.258802, 0.258162, 0.256082, 0.255332, 0.251992, 0.249982, 0.243532, 0.243492, 0.243382, 0.243302, 0.242952, 0.242902, 0.242642, 0.242402, 0.241242, 0.241162, 0.240852, 0.240622, 0.239592,
             0.239272, 0.238272, 0.237432, 0.235142, 0.235002, 0.234612, 0.234312, 0.233472, 0.233322, 0.232592, 0.231852, 0.229972, 0.229672, 0.228732, 0.227942, 0.225392, 0.224332, 0.220792, 0.218482, 0.211092, 0.210972, 0.210352, 0.209922, 0.207872, 0.207382, 0.205972, 0.204792, 0.201532, 0.201152, 0.199852, 0.198842, 0.196682, 0.195642, 0.192312, 0.190352, 0.182942, 0.182482, 0.180652, 0.179302, 0.175472, 0.173632, 0.168652, 0.165592, 0.157911, 0.156071, 0.151651, 0.149131, 0.141091, 0.136631, 0.127771, 0.122471, 0.102481, 0.102441, 0.102261, 0.102191, 0.101811, 0.101781, 0.101571, 0.101481, 0.100531, 0.100521, 0.100301, 0.100271, 0.0995609, 0.0994909, 0.0988609, 0.0986109, 0.0965809, 0.0965409, 0.0961809, 0.0959509, 0.0945809, 0.0942609, 0.0933209, 0.0927509, 0.0901609, 0.0899209, 0.0889208, 0.0883408, 0.0860408, 0.0852908, 0.0832208, 0.0815208, 0.0772207, 0.0771207, 0.0766807, 0.0764507, 0.0752307, 0.0750307, 0.0743307, 0.0738607, 0.0719007, 0.0718007, 0.0712307, 0.0708407,
             0.0696007, 0.0692407, 0.0681907, 0.0675206, 0.0653206, 0.0651506, 0.0643806, 0.0638806, 0.0619806, 0.0616306, 0.0600306, 0.0589006, 0.0561005, 0.0557205, 0.0544105, 0.0532605, 0.0509605, 0.0499405, 0.0474605, 0.0458404, 0.0426704, 0.0426304, 0.0423904, 0.0422304, 0.0416104, 0.0415404, 0.0408704, 0.0405904, 0.0390104, 0.0389204, 0.0383404, 0.0379404, 0.0367603, 0.0365303, 0.0353303, 0.0343603, 0.0318503, 0.0317403, 0.0310403, 0.0305903, 0.0289403, 0.0284203, 0.0269902, 0.0257802, 0.0232302, 0.0229002, 0.0214102, 0.0203202, 0.0181102, 0.0173002, 0.0154601, 0.0142501, 0.0127701, 0.0127101, 0.0124201, 0.0122601, 0.0117401, 0.0115501, 0.0110901, 0.0107701, 0.0100101, 0.00988009, 0.00943009, 0.00899008, 0.00819008, 0.00784007, 0.00705007, 0.00669006, 0.00590005, 0.00582005, 0.00510005, 0.00454004, 0.00355003, 0.00304003, 0.00225002, 0.00183002, 0.00144001, 0.00129001, 0.000910008, 0.000670006, 0.000550005, 0.000460004, 0.000340003, 0.000310003, 0.000210002, 0.000210002,
             0.000200002, 0.000200002, 0.000190002, 0.000190002, 0.000190002, 0.000180002, 0.000170002, 0.000170002, 0.000160001, 0.000160001, 0.000140001, 0.000140001, 0.000130001, 0.000110001, 8.00007e-05, 8.00007e-05, 8.00007e-05, 8.00007e-05, 8.00007e-05, 8.00007e-05, 7.00006e-05, 7.00006e-05, 6.00005e-05, 6.00005e-05, 5.00005e-05, 5.00005e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 2.00002e-05, 1.00001e-05, 1.00001e-05, 1.00001e-05, 1.00001e-05, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
             0};

    probs = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9992, 0.9992, 0.9992, 0.9992, 0.999, 0.999, 0.9988, 0.9988, 0.9984, 0.9984, 0.9984, 0.9984, 0.9982, 0.9982, 0.998, 0.998, 0.9978, 0.9978, 0.9978, 0.9978, 0.9978, 0.9978, 0.9978, 0.9978, 0.9976, 0.9976, 0.9976, 0.9976, 0.9976, 0.9976, 0.9976, 0.9976, 0.9976, 0.9976, 0.9976, 0.9976, 0.9976, 0.9976, 0.9972, 0.9972, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9964, 0.9964, 0.9964, 0.9964, 0.9964, 0.9964, 0.9964, 0.9964, 0.9964, 0.9964, 0.9964, 0.9964, 0.9962, 0.9962, 0.9962, 0.9962, 0.9962, 0.9962, 0.9962, 0.9962, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.9958, 0.9958, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995,
             0.995, 0.995, 0.995, 0.995, 0.9948, 0.9948, 0.9944, 0.9944, 0.9938, 0.9938, 0.9938, 0.9938, 0.9934, 0.9934, 0.9934, 0.9934, 0.993, 0.993, 0.993, 0.993, 0.993, 0.993, 0.993, 0.9928, 0.9926, 0.9926, 0.9926, 0.9926, 0.9926, 0.9926, 0.9926, 0.9926, 0.9924, 0.9924, 0.9924, 0.9924, 0.9924, 0.9924, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.992, 0.992, 0.9904, 0.9904, 0.9904, 0.9904, 0.9904, 0.9904, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.9898, 0.9898, 0.9898, 0.9898, 0.9898, 0.9898, 0.9898, 0.9898, 0.9898, 0.9898, 0.9896, 0.9896, 0.9896, 0.9896, 0.9896, 0.9896, 0.9894, 0.9894, 0.988, 0.988, 0.988, 0.988, 0.9878, 0.9878, 0.9878, 0.9874, 0.9874, 0.9874, 0.9874, 0.9874, 0.9874, 0.9874, 0.987, 0.986, 0.9842, 0.9842, 0.984, 0.9838, 0.9836, 0.9834, 0.9834, 0.982, 0.9806, 0.9802, 0.9798, 0.9796, 0.9778, 0.9776, 0.973, 0.9722, 0.9618, 0.9618, 0.9618, 0.9618, 0.9618, 0.9618, 0.9618, 0.9618,
             0.9612, 0.9612, 0.9612, 0.9612, 0.961, 0.961, 0.9604, 0.9604, 0.9604, 0.9604, 0.9604, 0.9604, 0.9604, 0.9604, 0.9598, 0.9596, 0.9592, 0.9592, 0.959, 0.9588, 0.9586, 0.9584, 0.9584, 0.9582, 0.957, 0.957, 0.957, 0.957, 0.957, 0.957, 0.9568, 0.9566, 0.9566, 0.9566, 0.9566, 0.9566, 0.9566, 0.9566, 0.9566, 0.9566, 0.9566, 0.9566, 0.9566, 0.9566, 0.9564, 0.9564, 0.9558, 0.9558, 0.9556, 0.9556, 0.9554, 0.9554, 0.9554, 0.9552, 0.955, 0.9546, 0.9534, 0.9534, 0.9534, 0.9534, 0.9534, 0.9534, 0.9534, 0.9532, 0.9526, 0.9526, 0.9526, 0.9524, 0.9518, 0.9518, 0.9516, 0.9516, 0.9516, 0.9516, 0.9516, 0.9516, 0.9516, 0.9516, 0.9512, 0.951, 0.9506, 0.9506, 0.9498, 0.9496, 0.9496, 0.9496, 0.9494, 0.9492, 0.9488, 0.9488, 0.9488, 0.9488, 0.9486, 0.9484, 0.9484, 0.9484, 0.9484, 0.9484, 0.9484, 0.9484, 0.9482, 0.9482, 0.948, 0.947, 0.946, 0.946, 0.946, 0.946, 0.9456, 0.9454, 0.9452, 0.945, 0.9434, 0.943, 0.9424, 0.942, 0.94, 0.94, 0.9338, 0.9334, 0.9226, 0.9226, 0.9224, 0.9224, 0.9224, 0.9224,
             0.9224, 0.9224, 0.9218, 0.9218, 0.9218, 0.9218, 0.9214, 0.9214, 0.921, 0.921, 0.9208, 0.9208, 0.9206, 0.9206, 0.9204, 0.9204, 0.92, 0.9198, 0.9196, 0.9196, 0.9192, 0.9192, 0.919, 0.9186, 0.9184, 0.9184, 0.9166, 0.9166, 0.9166, 0.9166, 0.9166, 0.9166, 0.9166, 0.9166, 0.9164, 0.9164, 0.9162, 0.9162, 0.9162, 0.916, 0.9152, 0.915, 0.9138, 0.9138, 0.9138, 0.9138, 0.9138, 0.9136, 0.9134, 0.9132, 0.9106, 0.9104, 0.9098, 0.9096, 0.9072, 0.907, 0.9022, 0.9008, 0.8908, 0.8908, 0.8908, 0.8908, 0.8908, 0.8908, 0.8906, 0.8906, 0.8902, 0.8902, 0.89, 0.89, 0.8898, 0.8898, 0.889, 0.8882, 0.8864, 0.8864, 0.8864, 0.8862, 0.8856, 0.8854, 0.8844, 0.884, 0.8822, 0.8816, 0.8808, 0.88, 0.8774, 0.8764, 0.8692, 0.8652, 0.8484, 0.848, 0.8466, 0.846, 0.8438, 0.8436, 0.8408, 0.839, 0.8352, 0.8352, 0.8332, 0.832, 0.8256, 0.824, 0.8174, 0.8146, 0.7948, 0.7944, 0.7932, 0.7914, 0.7824, 0.781, 0.7694, 0.7654, 0.7446, 0.7422, 0.7354, 0.7296, 0.7044, 0.6916, 0.6636, 0.6512, 0.5682, 0.5682, 0.5682, 0.5682,
             0.5682, 0.5682, 0.5682, 0.5682, 0.568, 0.568, 0.568, 0.568, 0.568, 0.568, 0.5678, 0.5678, 0.5676, 0.5676, 0.5676, 0.5676, 0.5674, 0.5674, 0.5672, 0.5672, 0.5672, 0.5672, 0.567, 0.567, 0.5664, 0.5664, 0.5664, 0.5664, 0.566, 0.566, 0.566, 0.566, 0.566, 0.566, 0.5658, 0.5658, 0.5658, 0.5658, 0.5658, 0.5658, 0.5658, 0.5658, 0.5656, 0.5656, 0.5656, 0.5656, 0.5656, 0.5656, 0.5652, 0.5652, 0.565, 0.5648, 0.5646, 0.5646, 0.5644, 0.5642, 0.5642, 0.5642, 0.564, 0.564, 0.5624, 0.5624, 0.5624, 0.5624, 0.5624, 0.5624, 0.5624, 0.5624, 0.5622, 0.5622, 0.5622, 0.5622, 0.5622, 0.5622, 0.5622, 0.5622, 0.562, 0.562, 0.562, 0.562, 0.562, 0.562, 0.5618, 0.5614, 0.5612, 0.5612, 0.561, 0.561, 0.5608, 0.5604, 0.5602, 0.5598, 0.559, 0.559, 0.559, 0.559, 0.559, 0.559, 0.5586, 0.5584, 0.558, 0.558, 0.558, 0.558, 0.558, 0.5578, 0.557, 0.5568, 0.5564, 0.5564, 0.5562, 0.556, 0.5556, 0.5556, 0.5552, 0.5552, 0.555, 0.555, 0.5544, 0.554, 0.5528, 0.5528, 0.5478, 0.5464, 0.5392, 0.5392, 0.5392, 0.5392,
             0.5392, 0.5392, 0.5392, 0.5392, 0.5392, 0.5392, 0.5392, 0.5392, 0.539, 0.539, 0.5386, 0.5386, 0.5386, 0.5386, 0.5386, 0.5386, 0.5382, 0.5382, 0.5378, 0.5378, 0.5376, 0.5376, 0.5374, 0.5372, 0.5372, 0.5372, 0.5372, 0.537, 0.5364, 0.5364, 0.5364, 0.5364, 0.5358, 0.5358, 0.5354, 0.5354, 0.5352, 0.5352, 0.5352, 0.5352, 0.5352, 0.535, 0.5344, 0.5342, 0.5334, 0.5334, 0.5332, 0.533, 0.5326, 0.5326, 0.5314, 0.531, 0.53, 0.5296, 0.5294, 0.5282, 0.5268, 0.5262, 0.5228, 0.5208, 0.5144, 0.5144, 0.5144, 0.5144, 0.5144, 0.5144, 0.514, 0.514, 0.5138, 0.5138, 0.5138, 0.5134, 0.5134, 0.5134, 0.513, 0.5124, 0.5106, 0.5106, 0.5102, 0.5096, 0.5092, 0.509, 0.508, 0.5074, 0.5054, 0.5054, 0.5042, 0.5034, 0.5006, 0.4996, 0.496, 0.4938, 0.4834, 0.4834, 0.4832, 0.482, 0.479, 0.4786, 0.477, 0.4762, 0.472, 0.4718, 0.4704, 0.4694, 0.4654, 0.4646, 0.46, 0.4572, 0.4462, 0.4454, 0.443, 0.4408, 0.4358, 0.4332, 0.4246, 0.4216, 0.4074, 0.4066, 0.4008, 0.3986, 0.385, 0.3784, 0.3624, 0.3544, 0.305, 0.305,
             0.305, 0.3048, 0.3048, 0.3048, 0.3048, 0.3048, 0.3042, 0.3042, 0.304, 0.304, 0.3026, 0.3024, 0.3022, 0.3014, 0.3002, 0.3002, 0.3002, 0.3, 0.2986, 0.2986, 0.2968, 0.2962, 0.2916, 0.2914, 0.291, 0.2906, 0.2866, 0.2864, 0.2836, 0.282, 0.2732, 0.273, 0.2726, 0.2726, 0.2712, 0.271, 0.2706, 0.2704, 0.2686, 0.2686, 0.2682, 0.2678, 0.2664, 0.266, 0.2652, 0.2642, 0.261, 0.261, 0.2606, 0.2602, 0.2582, 0.2576, 0.2566, 0.2546, 0.2474, 0.2474, 0.2452, 0.2424, 0.237, 0.2352, 0.2282, 0.2248, 0.2152, 0.2152, 0.2152, 0.215, 0.2142, 0.214, 0.2132, 0.2126, 0.2098, 0.2098, 0.2092, 0.2092, 0.2076, 0.2074, 0.205, 0.203, 0.1958, 0.1958, 0.195, 0.1946, 0.1912, 0.1906, 0.1848, 0.1808, 0.17, 0.1688, 0.1642, 0.1612, 0.1504, 0.1478, 0.1404, 0.1356, 0.1266, 0.1266, 0.1264, 0.1262, 0.1248, 0.1248, 0.1226, 0.1212, 0.1146, 0.1134, 0.1088, 0.1064, 0.0979999, 0.0969999, 0.0887999, 0.0853999, 0.0781999, 0.0776, 0.069, 0.062, 0.046, 0.0412, 0.0314, 0.025, 0.0182, 0.017, 0.014, 0.0132, 0.0106, 0.00939999,
             0.0076, 0.0072, 0.0044, 0.0044, 0.0044, 0.0044, 0.0044, 0.0044, 0.0044, 0.0044, 0.0044, 0.0044, 0.0044, 0.0044, 0.0044, 0.0042, 0.0042, 0.0042, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.0036, 0.0036, 0.0036, 0.0034, 0.0034, 0.0034, 0.0034, 0.0028, 0.0026, 0.0024, 0.0024, 0.0024, 0.0024, 0.0024, 0.0024, 0.0024, 0.0022, 0.0018, 0.0018, 0.0016, 0.0016, 0.0016, 0.0016, 0.0014, 0.000999999, 0.0008, 0.0008, 0.0008, 0.0006, 0.0006, 0.0004, 0.0004, 0.0004, 0.0004, 0.0004, 0.0004, 0.0004, 0.0004, 0.0004, 0.0002, 0.0002, 0.0002, 0.0002, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

    vector<u32> stages;
    for (u32 i = 0; i < E(16); i += E(newtile)) {
        stages.push_back(i);
    }
    vector<pair<u32, r_t>> probs_pair;
    for (u32 i = 0; i < probs.size(); ++i) {
        probs_pair.emplace_back(stages[i], probs[i]);
    }
    auto d_scores = calculate_d_scores(probs_pair, newtile);
    auto scores = calculate_scores(d_scores);
    auto scores_gains = calculate_scores_gains(scores, probs_pair);
    auto cumulative_score_gains = calculate_cumulative_score_gains(scores_gains);
    for (const auto &p: scores) {
        //cout << p.first << "->" << p.first + E(newtile) << ": " << p.second << endl;
    }
    for (u32 i = 0; i < scores_gains.size(); ++i) {
        cout << scores_gains[i].first << "->" << scores_gains[i].first + E(newtile) << ": " <<
             probs_pair[i].second << " " << scores[i].second << " " << scores_gains[i].second << " " << cumulative_score_gains[i].second << endl;
    }
}

vector<tuple<u32, u32, r_t, r_t, r_t, u8, u8>> print_bruteforce_stats(const u8 G, const u8 space) {
    vector<r_t> probs_6 = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9994, 0.9992, 0.9992, 0.9992, 0.9992, 0.999, 0.999, 0.9988, 0.9988, 0.9984, 0.9984, 0.9984, 0.9984, 0.9982, 0.9982, 0.998, 0.998, 0.9978, 0.9978, 0.9978, 0.9978, 0.9978, 0.9978, 0.9978, 0.9978, 0.9976, 0.9976, 0.9976, 0.9976, 0.9976, 0.9976, 0.9976, 0.9976, 0.9976, 0.9976, 0.9976, 0.9976, 0.9976, 0.9976, 0.9972, 0.9972, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9966, 0.9964, 0.9964, 0.9964, 0.9964, 0.9964, 0.9964, 0.9964, 0.9964, 0.9964, 0.9964, 0.9964, 0.9964, 0.9962, 0.9962, 0.9962, 0.9962, 0.9962, 0.9962, 0.9962, 0.9962, 0.996, 0.996, 0.996, 0.996, 0.996, 0.996, 0.9958, 0.9958, 0.995, 0.995, 0.995, 0.995, 0.995, 0.995,
                           0.995, 0.995, 0.995, 0.995, 0.995, 0.995, 0.9948, 0.9948, 0.9944, 0.9944, 0.9938, 0.9938, 0.9938, 0.9938, 0.9934, 0.9934, 0.9934, 0.9934, 0.993, 0.993, 0.993, 0.993, 0.993, 0.993, 0.993, 0.9928, 0.9926, 0.9926, 0.9926, 0.9926, 0.9926, 0.9926, 0.9926, 0.9926, 0.9924, 0.9924, 0.9924, 0.9924, 0.9924, 0.9924, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.9922, 0.992, 0.992, 0.9904, 0.9904, 0.9904, 0.9904, 0.9904, 0.9904, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.99, 0.9898, 0.9898, 0.9898, 0.9898, 0.9898, 0.9898, 0.9898, 0.9898, 0.9898, 0.9898, 0.9896, 0.9896, 0.9896, 0.9896, 0.9896, 0.9896, 0.9894, 0.9894, 0.988, 0.988, 0.988, 0.988, 0.9878, 0.9878, 0.9878, 0.9874, 0.9874, 0.9874, 0.9874, 0.9874, 0.9874, 0.9874, 0.987, 0.986, 0.9842, 0.9842, 0.984, 0.9838, 0.9836, 0.9834, 0.9834, 0.982, 0.9806, 0.9802, 0.9798, 0.9796, 0.9778, 0.9776, 0.973, 0.9722, 0.9618, 0.9618, 0.9618, 0.9618,
                           0.9618, 0.9618, 0.9618, 0.9618, 0.9612, 0.9612, 0.9612, 0.9612, 0.961, 0.961, 0.9604, 0.9604, 0.9604, 0.9604, 0.9604, 0.9604, 0.9604, 0.9604, 0.9598, 0.9596, 0.9592, 0.9592, 0.959, 0.9588, 0.9586, 0.9584, 0.9584, 0.9582, 0.957, 0.957, 0.957, 0.957, 0.957, 0.957, 0.9568, 0.9566, 0.9566, 0.9566, 0.9566, 0.9566, 0.9566, 0.9566, 0.9566, 0.9566, 0.9566, 0.9566, 0.9566, 0.9566, 0.9564, 0.9564, 0.9558, 0.9558, 0.9556, 0.9556, 0.9554, 0.9554, 0.9554, 0.9552, 0.955, 0.9546, 0.9534, 0.9534, 0.9534, 0.9534, 0.9534, 0.9534, 0.9534, 0.9532, 0.9526, 0.9526, 0.9526, 0.9524, 0.9518, 0.9518, 0.9516, 0.9516, 0.9516, 0.9516, 0.9516, 0.9516, 0.9516, 0.9516, 0.9512, 0.951, 0.9506, 0.9506, 0.9498, 0.9496, 0.9496, 0.9496, 0.9494, 0.9492, 0.9488, 0.9488, 0.9488, 0.9488, 0.9486, 0.9484, 0.9484, 0.9484, 0.9484, 0.9484, 0.9484, 0.9484, 0.9482, 0.9482, 0.948, 0.947, 0.946, 0.946, 0.946, 0.946, 0.9456, 0.9454, 0.9452, 0.945, 0.9434, 0.943, 0.9424, 0.942, 0.94, 0.94, 0.9338, 0.9334,
                           0.9226, 0.9226, 0.9224, 0.9224, 0.9224, 0.9224, 0.9224, 0.9224, 0.9218, 0.9218, 0.9218, 0.9218, 0.9214, 0.9214, 0.921, 0.921, 0.9208, 0.9208, 0.9206, 0.9206, 0.9204, 0.9204, 0.92, 0.9198, 0.9196, 0.9196, 0.9192, 0.9192, 0.919, 0.9186, 0.9184, 0.9184, 0.9166, 0.9166, 0.9166, 0.9166, 0.9166, 0.9166, 0.9166, 0.9166, 0.9164, 0.9164, 0.9162, 0.9162, 0.9162, 0.916, 0.9152, 0.915, 0.9138, 0.9138, 0.9138, 0.9138, 0.9138, 0.9136, 0.9134, 0.9132, 0.9106, 0.9104, 0.9098, 0.9096, 0.9072, 0.907, 0.9022, 0.9008, 0.8908, 0.8908, 0.8908, 0.8908, 0.8908, 0.8908, 0.8906, 0.8906, 0.8902, 0.8902, 0.89, 0.89, 0.8898, 0.8898, 0.889, 0.8882, 0.8864, 0.8864, 0.8864, 0.8862, 0.8856, 0.8854, 0.8844, 0.884, 0.8822, 0.8816, 0.8808, 0.88, 0.8774, 0.8764, 0.8692, 0.8652, 0.8484, 0.848, 0.8466, 0.846, 0.8438, 0.8436, 0.8408, 0.839, 0.8352, 0.8352, 0.8332, 0.832, 0.8256, 0.824, 0.8174, 0.8146, 0.7948, 0.7944, 0.7932, 0.7914, 0.7824, 0.781, 0.7694, 0.7654, 0.7446, 0.7422, 0.7354, 0.7296,
                           0.7044, 0.6916, 0.6636, 0.6512, 0.5682, 0.5682, 0.5682, 0.5682, 0.5682, 0.5682, 0.5682, 0.5682, 0.568, 0.568, 0.568, 0.568, 0.568, 0.568, 0.5678, 0.5678, 0.5676, 0.5676, 0.5676, 0.5676, 0.5674, 0.5674, 0.5672, 0.5672, 0.5672, 0.5672, 0.567, 0.567, 0.5664, 0.5664, 0.5664, 0.5664, 0.566, 0.566, 0.566, 0.566, 0.566, 0.566, 0.5658, 0.5658, 0.5658, 0.5658, 0.5658, 0.5658, 0.5658, 0.5658, 0.5656, 0.5656, 0.5656, 0.5656, 0.5656, 0.5656, 0.5652, 0.5652, 0.565, 0.5648, 0.5646, 0.5646, 0.5644, 0.5642, 0.5642, 0.5642, 0.564, 0.564, 0.5624, 0.5624, 0.5624, 0.5624, 0.5624, 0.5624, 0.5624, 0.5624, 0.5622, 0.5622, 0.5622, 0.5622, 0.5622, 0.5622, 0.5622, 0.5622, 0.562, 0.562, 0.562, 0.562, 0.562, 0.562, 0.5618, 0.5614, 0.5612, 0.5612, 0.561, 0.561, 0.5608, 0.5604, 0.5602, 0.5598, 0.559, 0.559, 0.559, 0.559, 0.559, 0.559, 0.5586, 0.5584, 0.558, 0.558, 0.558, 0.558, 0.558, 0.5578, 0.557, 0.5568, 0.5564, 0.5564, 0.5562, 0.556, 0.5556, 0.5556, 0.5552, 0.5552, 0.555, 0.555,
                           0.5544, 0.554, 0.5528, 0.5528, 0.5478, 0.5464, 0.5392, 0.5392, 0.5392, 0.5392, 0.5392, 0.5392, 0.5392, 0.5392, 0.5392, 0.5392, 0.5392, 0.5392, 0.539, 0.539, 0.5386, 0.5386, 0.5386, 0.5386, 0.5386, 0.5386, 0.5382, 0.5382, 0.5378, 0.5378, 0.5376, 0.5376, 0.5374, 0.5372, 0.5372, 0.5372, 0.5372, 0.537, 0.5364, 0.5364, 0.5364, 0.5364, 0.5358, 0.5358, 0.5354, 0.5354, 0.5352, 0.5352, 0.5352, 0.5352, 0.5352, 0.535, 0.5344, 0.5342, 0.5334, 0.5334, 0.5332, 0.533, 0.5326, 0.5326, 0.5314, 0.531, 0.53, 0.5296, 0.5294, 0.5282, 0.5268, 0.5262, 0.5228, 0.5208, 0.5144, 0.5144, 0.5144, 0.5144, 0.5144, 0.5144, 0.514, 0.514, 0.5138, 0.5138, 0.5138, 0.5134, 0.5134, 0.5134, 0.513, 0.5124, 0.5106, 0.5106, 0.5102, 0.5096, 0.5092, 0.509, 0.508, 0.5074, 0.5054, 0.5054, 0.5042, 0.5034, 0.5006, 0.4996, 0.496, 0.4938, 0.4834, 0.4834, 0.4832, 0.482, 0.479, 0.4786, 0.477, 0.4762, 0.472, 0.4718, 0.4704, 0.4694, 0.4654, 0.4646, 0.46, 0.4572, 0.4462, 0.4454, 0.443, 0.4408, 0.4358, 0.4332,
                           0.4246, 0.4216, 0.4074, 0.4066, 0.4008, 0.3986, 0.385, 0.3784, 0.3624, 0.3544, 0.305, 0.305, 0.305, 0.3048, 0.3048, 0.3048, 0.3048, 0.3048, 0.3042, 0.3042, 0.304, 0.304, 0.3026, 0.3024, 0.3022, 0.3014, 0.3002, 0.3002, 0.3002, 0.3, 0.2986, 0.2986, 0.2968, 0.2962, 0.2916, 0.2914, 0.291, 0.2906, 0.2866, 0.2864, 0.2836, 0.282, 0.2732, 0.273, 0.2726, 0.2726, 0.2712, 0.271, 0.2706, 0.2704, 0.2686, 0.2686, 0.2682, 0.2678, 0.2664, 0.266, 0.2652, 0.2642, 0.261, 0.261, 0.2606, 0.2602, 0.2582, 0.2576, 0.2566, 0.2546, 0.2474, 0.2474, 0.2452, 0.2424, 0.237, 0.2352, 0.2282, 0.2248, 0.2152, 0.2152, 0.2152, 0.215, 0.2142, 0.214, 0.2132, 0.2126, 0.2098, 0.2098, 0.2092, 0.2092, 0.2076, 0.2074, 0.205, 0.203, 0.1958, 0.1958, 0.195, 0.1946, 0.1912, 0.1906, 0.1848, 0.1808, 0.17, 0.1688, 0.1642, 0.1612, 0.1504, 0.1478, 0.1404, 0.1356, 0.1266, 0.1266, 0.1264, 0.1262, 0.1248, 0.1248, 0.1226, 0.1212, 0.1146, 0.1134, 0.1088, 0.1064, 0.0979999, 0.0969999, 0.0887999, 0.0853999,
                           0.0781999, 0.0776, 0.069, 0.062, 0.046, 0.0412, 0.0314, 0.025, 0.0182, 0.017, 0.014, 0.0132, 0.0106, 0.00939999, 0.0076, 0.0072, 0.0044, 0.0044, 0.0044, 0.0044, 0.0044, 0.0044, 0.0044, 0.0044, 0.0044, 0.0044, 0.0044, 0.0044, 0.0044, 0.0042, 0.0042, 0.0042, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.0036, 0.0036, 0.0036, 0.0034, 0.0034, 0.0034, 0.0034, 0.0028, 0.0026, 0.0024, 0.0024, 0.0024, 0.0024, 0.0024, 0.0024, 0.0024, 0.0022, 0.0018, 0.0018, 0.0016, 0.0016, 0.0016, 0.0016, 0.0014, 0.000999999, 0.0008, 0.0008, 0.0008, 0.0006, 0.0006, 0.0004, 0.0004, 0.0004, 0.0004, 0.0004, 0.0004, 0.0004, 0.0004, 0.0004, 0.0002, 0.0002, 0.0002, 0.0002, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};

    vector<u32> stages;
    for (u32 i = 0; i < E(16); i += E(G)) {
        stages.push_back(i);
    }

    vector<pair<u32, r_t>> probs;
    for (u32 i = 0, j = E(G - 6) - 1; j < probs_6.size(); i++, j += E(G - 6)) {
        probs.emplace_back(stages[i], probs_6[j]);
    }
    probs.emplace_back(stages.back(), 0);

    auto d_probs = calculate_d_probs_from_probs(probs);


    auto d_scores = calculate_d_scores(probs, G);
    auto scores = calculate_scores(d_scores);
    auto scores_gains = calculate_scores_gains(scores, probs);
    auto cumulative_score_gains = calculate_cumulative_score_gains(scores_gains);

    //print the size of all arrays
    /*cout << stages.size() << endl;
    cout << probs.size() << endl;
    cout << d_probs.size() << endl;
    cout << d_scores.size() << endl;
    cout << scores.size() << endl;
    cout << scores_gains.size() << endl;
    cout << cumulative_score_gains.size() << endl;*/

    vector<tuple<u32, u32, r_t, r_t, r_t, u8, u8>> result;
    for (u32 i = 0; i < d_probs.size(); ++i) {
        const u32 sum = d_probs[i].first;
        const u8 act_G = calculate_G(sum, G);
        const u8 act_space = calculate_space(sum, act_G);
        if (probs[i].second == 0) { continue; }
        if (d_probs[i].second > 0.99) { continue; }
        if (act_G != G || act_space != space) { continue; }
        result.emplace_back(probs[i].first, probs[i].first + E(G), d_probs[i].second, probs[i].second, cumulative_score_gains[i + 1].second, G, space);
    }
    return result;
}

void print_all_bruteforces(r_t GB_limit) {
    vector<tuple<u32, u32, r_t, r_t, r_t, u8, u8>> all_cases;
    for (u8 G = 6; G <= 14; ++G) {
        for (u8 space = G; space <= 15; ++space) {
            r_t GB = power(G + 1, space) / 8e9 * 32;
            if (GB > GB_limit) { continue; }

            auto G_space_cases = print_bruteforce_stats(G, space);
            if (G_space_cases.size() == 0) {
                continue;
            }
            //cout << "G,space = " << u32(G) << "," << u32(space) << " | GB = " << GB << endl;
            for (const auto &c: G_space_cases) {
                //cout << get<0>(c) << "->" << get<0>(c) + E(G) << ": " << get<1>(c) << " " << get<2>(c) << " " << get<3>(c) << endl;
            }
            //cout << endl;

            all_cases.insert(all_cases.end(), G_space_cases.begin(), G_space_cases.end());
        }
    }
    vector<tuple<u32, u32, r_t, r_t, r_t, u8, u8>> filtered_all_cases;
    //iterate through all cases and filter out the ones that are included by another case, meaning that interval by the first two u32s is a sub-interval of another interval
    for (u32 i = 0; i < all_cases.size(); ++i) {
        const auto &c = all_cases[i];
        bool is_included = false;
        for (u32 j = 0; j < all_cases.size(); ++j) {
            if (i == j) { continue; }
            const auto &c2 = all_cases[j];
            //if intervals match perfectly, print the interval
            if (get<0>(c) == get<0>(c2) && get<1>(c) == get<1>(c2)) {
                cout << get<0>(c) << "->" << get<1>(c) << ": " << get<2>(c) << " " << get<3>(c) << " " << get<4>(c) << endl;
                assert(false);
            }
            if (get<0>(c) >= get<0>(c2) && get<1>(c) <= get<1>(c2)) {
                is_included = true;
                break;
            }
        }
        if (!is_included) {
            filtered_all_cases.push_back(c);
        }
    }
    //sort by (1 - d_prob) * cumulative_score_gain * prob
    sort(filtered_all_cases.begin(), filtered_all_cases.end(), [](const auto &a, const auto &b) {
        return (1 - get<2>(a)) * get<4>(a) * get<3>(a) > (1 - get<2>(b)) * get<4>(b) * get<3>(b);
    });
    cout << fixed << setprecision(2);
    for (const auto &c: filtered_all_cases) {
        cout << "G,sp= " << u32(get<5>(c)) << "," << u32(get<6>(c)) << " | GB= " << power(get<5>(c) + 1, get<6>(c)) / 8e9 * 32 << "\t| ";
        cout << get<0>(c) << "->" << get<1>(c) << ": " << get<2>(c) << " " << get<3>(c) << " " << (1 - get<2>(c)) * get<4>(c) * get<3>(c) << endl;
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Verify the assumption that large tiles stay in the same place
//////////////////////////////////////////////////////////////////////////////////////////////

u64 get_largest_transformation(u64 board) {
    for (const u64 b: get_transformations(board)) {
        board = max(board, b);
    }
    return board;
}

u64 get_base_type(const u64 board, const u8 G) {
    u64 base_type = 0;
    for (u8 i = 0; i < 16; ++i) {
        const u8 cell = (board >> (i * 4)) & 0xFu;
        u8 base = 0;
        if (cell == G) {
            base = G;
        } else if (cell > G) {
            base = 0xFu;
        }
        base_type |= u64(base) << (i * 4);
    }
    return base_type;
}

vector<u64> get_level_starts(const u32 n, const u16 level_mask, const u8 G, Dir (*algorithm)(const u64, NTuple &)) {
    vector<u64> level_starts;
    while (level_starts.size() < n) {
        u64 board = 0;
        fill_board(board);
        fill_board(board);
        bool next_stage = false;
        while (true) {
            const Dir dir = algorithm(board, next_stage ? tuples_4_stage_2 : tuples_4_stage_1);
            if (dir == None) { break; }
            move_board(board, dir);
            fill_board(board);
            next_stage |= highest_tile(board) >= 14;
            if (get_large_tiles_mask(board, G) == level_mask) {
                level_starts.push_back(board);
                break;
            }
        }
        if (level_starts.size() % 10 == 0) {
            cout << "Progress: " << r_t(level_starts.size()) / r_t(n) << endl;
        }
    }
    return level_starts;
}

tuple<u64, bool, pair<u64, u64>> save_level(const u64 level_start, const u16 level_mask, const u8 G, Dir (*algorithm)(const u64, NTuple &)) {
    u64 board = level_start;
    bool next_stage = false;
    pair<u64, u64> optional_change = {0, 0};
    while (true) {
        const Dir dir = algorithm(board, next_stage ? tuples_4_stage_2 : tuples_4_stage_1);
        if (dir == None) { break; }
        const u64 old_board = board;
        move_board(board, dir);
        fill_board(board);
        next_stage |= highest_tile(board) >= 14;

        if (get_large_tiles_mask(board, G) != level_mask) {
            return {level_start, true, optional_change};
        }
        if (optional_change.first != 0) {
            continue;
        }
        bool changed = false;
        for (u8 i = 0; i < 16; ++i) {
            const u8 base = (get_base_type(level_start, G) >> (i * 4)) & 0xFu;
            const u8 start = (level_start >> (i * 4)) & 0xFu;
            const u8 cell = (board >> (i * 4)) & 0xFu;
            if (base != 0 && cell != start) {
                //cout << u32(i) << endl;
                //cout << u32(base) << endl;
                //cout << u32(start) << endl;
                //cout << u32(cell) << endl;
                //print_board(level_start);
                //print_board(get_base_type(level_start, G));
                //print_board(old_board);
                //print_board(board);
                //cout << endl << endl;
                changed = true;
                break;
            }
        }
        if (changed) {
            optional_change = {old_board, board};
        }
    }

    return {level_start, false, optional_change};
}

vector<tuple<u64, bool, pair<u64, u64>>> collect_levels(const u32 n, const u32 k, const u16 level_mask, const u8 G, Dir (*algorithm)(const u64, NTuple &)) {
    vector<u64> level_starts = get_level_starts(n, level_mask, G, algorithm);
    vector<tuple<u64, bool, pair<u64, u64>>> levels;
    for (const u64 level_start: level_starts) {
        for (u32 i = 0; i < k; ++i) {
            //u64 board = save_level(level_mask, algorithm);
            auto [start, success, optional_change] = save_level(level_start, level_mask, G, algorithm);
            if (start == 0) { continue; }
            levels.emplace_back(start, success, optional_change);
        }
    }
    return levels;
}

//base, success rate, no change rate, no change success rate, change success rate, change success boards
vector<tuple<u64, r_t, r_t, r_t, r_t, vector<pair<u64, u64>>, r_t>> get_all_level_stats(const u32 n, const u32 k, const u16 level_mask, const u8 G, Dir (*algorithm)(const u64, NTuple &)) {
    //no change success, no change fail, change success, change fail
    unordered_map<u64, tuple<u32, u32, u32, u32>> counts;
    unordered_map<u64, vector<pair<u64, u64>>> change_success_boards;
    for (const auto [level_start, success, optional_change]: collect_levels(n, k, level_mask, G, algorithm)) {
        const u64 base_type = get_largest_transformation(get_base_type(level_start, G));
        bool change = optional_change.first != 0;
        auto [A, B, C, D] = counts[base_type];
        if (change) {
            if (success) {
                C++;
                change_success_boards[base_type].push_back(optional_change);
            } else {
                D++;
            }
        } else {
            if (success) {
                A++;
            } else {
                B++;
            }
        }
        counts[base_type] = {A, B, C, D};
    }
    vector<tuple<u64, u32, u32, u32, u32>> counts_vec;
    for (const auto &[base, ABCD]: counts) {
        counts_vec.push_back({base, get<0>(ABCD), get<1>(ABCD), get<2>(ABCD), get<3>(ABCD)});
    }
    //sort by total count
    sort(counts_vec.begin(), counts_vec.end(), [](const auto &a, const auto &b) {
        return get<1>(a) + get<2>(a) + get<3>(a) + get<4>(a) > get<1>(b) + get<2>(b) + get<3>(b) + get<4>(b);
    });
    vector<tuple<u64, r_t, r_t, r_t, r_t, vector<pair<u64, u64>>, r_t>> result;
    for (const auto &[base, A, B, C, D]: counts_vec) {
        const r_t success_rate = r_t(A + C) / r_t(A + B + C + D);
        const r_t no_change_rate = r_t(A + B) / r_t(A + B + C + D);
        const r_t no_change_success_rate = r_t(A) / r_t(A + B);
        const r_t change_success_rate = r_t(C) / r_t(C + D);
        const r_t frequency = r_t(A + B + C + D) / r_t(n * k);
        result.emplace_back(base, success_rate, no_change_rate, no_change_success_rate, change_success_rate, change_success_boards[base], frequency);
    }
    return result;
}

void collect_results() {
    /*
    repeat playgame {
        if doesnt reach start mask:
            throw out
        else:
            save level start formation
            continue game
            if formation changes:
                save why it changed
            if mask changes:
                save that is succeeded
            if terminates:
                save that it failed
    }
    */
    /*
    data stored:
    - level start formation
    - succeeded or failed
    - why it changed (new board is enough)
    */
}

vector<pair<u64, r_t>> change_success_bases(const vector<pair<u64, u64>> change_success_boards, const u8 G) {
    unordered_map<u64, r_t> bases;
    for (const auto [old_board, new_board]: change_success_boards) {
        bases[get_largest_transformation(get_base_type(new_board, G))]++;
    }
    vector<pair<u64, r_t>> bases_vec;
    for (const auto &[base, count]: bases) {
        bases_vec.push_back({base, count / r_t(change_success_boards.size())});
    }
    sort(bases_vec.begin(), bases_vec.end(), [](const auto &a, const auto &b) {
        return a.second > b.second;
    });
    return bases_vec;
}

void print_change_success_bases(u32 n, u32 k, u16 level_mask, u8 G, Dir (*algorithm)(const u64, NTuple &)) {
    auto res = get_all_level_stats(n, k, level_mask, G, algorithm);
    for (const auto [base, success_rate, no_change_rate, no_change_success_rate, change_success_rate, change_success_boards, frequency]: res) {
        cout << "frequency: " << frequency << endl;
        cout << "success: " << success_rate << endl;
        cout << "no change: " << no_change_rate << endl;
        cout << "no change success: " << no_change_success_rate << endl;
        cout << "change success: " << change_success_rate << endl;
        print_board(base);
        //continue;
        cout << "change success boards: " << endl;
        auto change_success_freqs = change_success_bases(change_success_boards, G);
        for (const auto [base, freq]: change_success_freqs) {
            cout << freq << endl;
            print_board(base);
        }

        r_t avg_sum = 0;
        for (const auto [old_board, new_board]: change_success_boards) {
            print_board(old_board);
            print_board(new_board);
            cout << endl;
            for (u32 i = 0; i < 16; ++i) {
                if (get_cell(old_board, i) < G) {
                    avg_sum += E(get_cell(old_board, i));
                }
            }
        }
        cout << "avg sum: " << avg_sum / r_t(change_success_boards.size()) << endl;
    }
}